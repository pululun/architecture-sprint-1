Исходя из описания приложения у него есть 4 основные функции, а именно "загрузка фотографий", "удаление фотографий", "сбор и учёт лайков под фото", "создание профиля и его редактирование".
На базе этих функций можно разбить приложение на два отдельных микрофронтенда.
1) (загрузка/удаление фотографий, сбор/учёт лайков под фото) - микрофронтенд работы с карточкой фотографии.
2) (создание профиля и его редактирование) - микрофронтенд работы с карточкой профиля пользователя.
На старте приложеня, команда была небольшой и бизнес хотел быстрее получить MVP продукта, поэтому было принято решение, что для этих требований подойдёт монолитная структура фронтэнда. Первый этап завершился успешно и бизнес хочет много нового функционала, в том числе и функционала который затрагивает существующий, что бы упростить, ускорить и иметь возможность параллельной работы над новыми функциями необходимо разделить монолитную структуру на микрофронтенды. 
На данный момент исходя из зависимостей в файле "package.json" я предполагаю, что команда состоит из разработчиков на react.  
Проект будет развиваться очень динамично, у бизнеса очень много пожеланий для его развития поэтому в качестве реализации был выбран подход "Run time", из-за его преимуществ: 
1)Разные команды очень часто будут доставлять новые фичи, а так как у них спринты начинаются и заканчиваются в разное время, то нужен подход который будет независимым. 
2)Разные микрофронтенды могут и будут реализованы на разных технологиях (react, angular, vue) 
3)Когда появляется ещё один микрофронтэнд и ещё одна команда разработки, то они сразу могут начать работать над новым функционалом.
В качестве метода компоновки выбран "гибридный подход", так как бэкенд распиливается на микросервисы и в будущем планируется BFF, а так же есть некоторая логика связанная с лайками под фото которая должна хранится и обрабатываться на стороне сервера, при этом сам сервер не занимается рендором страниц, а просто предоставляет API для взаимодействия с ним.
Выбор инструмента для реализации пал на "Webpack Module Federation", так как планируется реализация микрофронтендов на фреймворках. (у команды нет опыта в других фреймворках)
В качестве межмодульного взаимодействия на начальном этапе будет использоваться API, а в последствии будет реализован BFF - это обусловлено тем, что для общения микрофронтендов между собой на данном этапе будет достаточно простого REST API, а в последствии на стороне бэкенда будет создан BFF. Так как выше заявлена полная независимость команд друг от друга, можно так же сделать реализацию через Pub/Sub.  

П.С. Если смотреть на код проекта, то может сложиться впечатление, что можно сформировать ещё один независимый микрофронтенд (исходя из опыта профиль всегда так или иначе строится на данных о пользователе), а именно разделить профиль пользователя и аутентификацию\авторизацию на два независимых микрофронтенда, но исходя из сооброжений, что 1 микрофронтенд - это одна команда, то на мой взгляд, после реализации регистрации и авторизации команда переключится на другой микрофронтенд и может получиться ситуация, что микрофронтенд по аутентификации\авторизации никто не поддерживает, исходя из того, что аутентификация\авторизация будет реализована на строне бэкенда, то компоненты связанные с REST запросами меняться не будут, при этом команда занимающаяся основной функциональность - профилем пользователя будет так же ответственна и за эти REST вызовы вынесенные в отдельные компоненты. (на мой взгляд разделение на два микрофронтенда избыточно в виду слишком маленького функционала)

Представляю вариант разбиения на микрофронты:
```
/frontend
|-- /microfrontend
|   |-- /mf-user-profile
|   |   |-- /src
|   |   |   |-- /components
|   |   |   |   |-- App.js
|   |   |   |   |-- EditAvatarPopup.js
|   |   |   |   |-- EditProfilePopup.js
|   |   |   |   |-- Header.js
|   |   |   |   |-- InfoTooltip.js
|   |   |   |   |-- Login.js
|   |   |   |   |-- Register.js
|   |   |   |
|   |   |   |-- /utils
|   |   |   |   |-- api.js
|   |   |   |   |-- event.js
|   |   |   |   
|   |   |   |-- package.json
|   |   |   |-- webpack.config.js
|   |
|   |-- /mf-photo-card
|   |   |-- /src
|   |   |   |-- /components
|   |   |   |   |-- AddPlacePopup.js
|   |   |   |   |-- App.js
|   |   |   |   |-- Card.js
|   |   |   |   |-- ImagePopup.js
|   |   |   |   
|   |   |   |-- /utils
|   |   |   |   |-- api.js
|   |   |   |   |-- event.js
|   |   |   |   
|   |   |   |-- package.json
|   |   |   |-- webpack.config.js
|   |
|
|-- /src
|   |-- /components
|   |   |-- Main.js
|   |   |-- PopupWithForum.js
|   |   |-- Footer.js
|   |   |-- ProtectedRoute.js
|   |   |
|   |
|   |-- /utils
|   |   |-- api.js
|   |   |-- event.js
|   |
|   |-- package.json
|   |-- webpack.config.js
```
В приведённой структуре выше, в каталоге "components" содержатся компоненты которые, относятся к определённой бизнес функции, в каталоге "utils" содержатся API и\или pub\sub, а так же файлы "package.json" в котором содержатся данные о подключенных библиотеках и "webpack.config.js" файл в хостовом микрофронтенде описывается сам модуль и все подключаемые к нему микрофронтенды (remote) - в моём случае это "mf-photo-card" и "mf-user-profile". А в микрофронтендах в файле "webpack.config.js" описываются сами модули и указывается хостовый (remote).

***
## Декомпозиция монолитного веб-приложения на Django в микросервисы
Монолитная архитектура сервиса которая по началу давала преимущества в скорости разработки, упрощала получение данных на уровне БД и в сложности\скорости доставки проблем не было, так как нужно было только развернуть данный сервис на единственном сервере и всё.  
Но время шло и все три ранее описанных преимущества превратились в недостатки, а именно:  
Монолитная архитектура со временем обросла жёсткими связями между классами и любая доработка или нововведение - это очень дорого по времени и опасно с точки зрения повреждения ранее написанного функционала. Если в работе монолита будет найден дефект, то в большинстве случаев выявить и исправить его будет очень долго по времени и сложно по реализации, так как после исправления будет необходимо провести полное тестирование всех функций монолита. На ранних этапах разработки монолит разворачивался на сервере довольно просто, но теперь когда разработчиков, которые развивают и поддерживают код стало больше и код разросся, каждому из них нужен отдельный сервер для развёртывания и тестирования изменённого ими функционала - это стало очень дорого, а сборка и доставка монолита на сервер начала занимать от 40 минут до часа, из за этого цена ошибки в коде становится очень высока. А так же сделать доработку или выпустить новую функциональность стало очень сложно, так как релизы становятся всё более редкими, из-за процесса, который всё более замедляется с каждым новым релизом.  
Микросервисная архитектура усложнит некоторые процессы на старте (развёртывание, конфигурирование, реализацию логирования и мониторинга) и изменит порядок проектирования (нужно будет более детально продумывать реализацию на перёд, так как у каждого микросервиса своя база данных и это значит, что усложняется доступ к данным (получение, создание, обновление и удаление) так как появляются распределённые транзакции и если по пути выполнения операции в одном или нескольких микросервисах произойдёт сбой, то могут появиться не консистентные данные, что может привести к большим финансовым потерям), но есть и положительные стороны, микросервисная архитектура может предложить упрощение и ускорение процесса разработки за счёт упрощения модели данных,  ускорения доставки сервиса на стенд за счёт автоматизации и унификации процесса сборки и развёртывания, благодаря централизованному механизму логирования и мониторинга значительно упроститься выявление и устранение проблем.  Я перечислил не всё, но думаю этого достаточно, так как несмотря на недостатки микросервисной архитектуры - скорость с которой ведётся разработка и доставка новых функций и исправление старых проблем является приоритетом для бизнеса, то микросервисная архитектура значительно ускоряет этот процесс.  

### Декомпозиция
* Исходя из бизнес функций монолита я решил разделить его на 12 микросервисов. 
* Провести технический анализ <u>не представляется возможным</u>, так как отсутствуют компетенции в "python\djangol". 
* Провести анализ KPI, SLO и SLI <u>не представляется возможным</u>, так как нет доступа к стенду и сервисам на базе которых можно было бы посмотреть эти данные.  
### План перевода
Исходя из того, что компетенций по созданию слоя "Anti-Corruption Layer" не у котого нет и это сильно удорожит реализацию, было принято решение отказаться от него и просто сделать реализацию на маршрутизации. Так же для обмена данными между микросервисами будет использоваться две технологии, Apache kafka и REST. (Все функции микросервисов отражены в draw.io)
* Для перевода монолита на микросервисы я предлагаю начать с реализации микросервисов "окружения", таких, как "микросервис GW" - который будет выполнять роль маршрутизатора и на нём будут храниться проверки ролевой модели\эндпоинтов, "микросервис нотификаций" - который будет отправлять оповещения о происходящих событиях в разные источники (почта, мессенджеры и д.р.), а так же библиотеку со стандартным API (kafka + "JSON"), что бы для интеграции с сервисом уведомлений достаточно было просто подключить эту библиотеку и вызвать класс который сформирует необходимый "JSON" и отправит его в нужный топик. И микросервис по формированию отчётов - на базе которого можно будет формировать отчёты по разным сценариям и запросам, интеграция с ним так же должна быть на базе kafka топика, как и в микросервисе нотификации. (эти сервисы на данном этапе никак не влияют на бизнес,  никаких остановок разработки бизнес функций не будет)

* После этого я предложил бы начать реализацию микросервиса "управления пользователями и их ролями" (сейчас нет требований к высокой нагрузке и кастомизации разрешений (permission) в рамках базовых ролей, а значит нет смысла разделять пользователей и их роли, а так же исходя из бизнес-требований была выбрана реализация Role-based access control (RBAC)), реализация будет на базе JWT токена, а так же будет реализован функционал по формированию и пробрасыванию в микросервисы хедера "Auth" в котором в формате JSON будет хранится объект пользователя который сделал этот вызов, и плюсом к этому будет сформирована библиотека, которая подключается во все микросервисы для которых нужны эти данные и в рамках которого этот JSON будет разбираться внутри микросервиса и появится возможность получить эти данные как объект (без прямых вызовов API).

* Следующим микросервисом я бы взял "микросервис управления платежами", его API в kafka и REST должны быть унифицированы для последующих интеграций, а так же микросервисы (адаптеры) для каждой из реализаций - это позволит снизить будущие риски при изменении или подключении новых реализаций платёжных шлюзов.

* Следующим микросервисом я взял бы "микросервис Orchestrator (saga)", так как микросервисы "управления товарами и услугами" и "управления заказами"  тесно связанны и для их нормальной работы нужны транзакции. Дальше я последовательно перевёл бы и оба бизнес-сервиса.

* Заключительным событием я бы перевёл "Микросервис управления заявками".

П.С. В приложенном файле декомпозиция находится во второй вкладке "microservices"